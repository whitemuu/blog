#+TITLE: asymptotic analysis
#+AUTHOR: angus zhang
#+DATE: 2018-12-11T14:06:15CST
#+OPTIONS: \n:t
#+TAGS: asymptotic algorithm big-O

asymptotic(渐近线) analysis | big-X
these are mathematics notions; In *CS* we only use big-Oh, which is actually big-Θ in mathematics.

another line

* Bachmann–Landau notations

Family of Bachmann–Landau notations
1) o(X) -- The algorithm won't take longer than X
2) O(X) -- The algorithm won't take longer than X, give or take a constant multiplier
3) Θ(X) -- The algorithm will  take as long as  X, give or take a constant multiplier <- best description if possible
4) ω(X) -- The algorithm will  take longer than X
5) Ω(X) -- The algorithm will  take longer than X, give or take a constant multiplier  i.e. best-case | lower bound


| Name         | Notation |    n=10 |         n=100 | example           |
|--------------+----------+---------+---------------+-------------------|
| Constant     | 1        |       1 |             1 | x + y             |
| Logarithmic  | logN     |       3 |             7 | binary search     |
| Linear       | N        |      10 |           100 | loop              |
| Linearithmic | NlogN    |      30 |           700 | merge/quick sort  |
| Quadratic    | N^2      |     100 |         10000 | nested loop       |
| Cubic        | N^3      |    1000 |       1000000 | triple loop       |
| Exponential  | 2^n      |    1024 |  1.267650e+30 | check all subsets |
| Factorial    | n!       | 3628800 | 9.332622e+157 |                   |

#+BEGIN_QUOTE
Where there is a will, there is a way.
#+END_QUOTE
** Venn's diagram

Venn's diagram
#+BEGIN_SRC
┌──────────────────────┐
│   O(g(n))    ┌───────┼──────────────┐
│              │       │   Ω(g(n))    │
│  ┌─────────┐ │       │              │
│  │ o(g(n)) │ │Θ(g(n))│ ┌─────────┐  │
│  └─────────┘ │       │ │ ω(g(n)) │  │
└──────────────┼───────┘ └─────────┘  │
               └──────────────────────┘
#+END_SRC

Map的核心思想就是可以比线性查找更快. 通过散列值(hash)作为键(key)来定位对象的过程分为两步:在Map内部,存储着一个顶层数组,顶层数组的每个元素指向其他的数组,查找或存储的时候,先根据key对象的hashCode()值计算出数组的索引,然后到这个索引找到所指向的第二层线性数组,使用equals方法来比较是否有相应的值(以返回或者存储).

Java
#+BEGIN_SRC java
  public static void countDown(int start, int delay) {
      ActionListener listener = event -> {
          start--; // Error: Can't mutate captured variable
          System.out.println(start);
      };
      new Timer(delay, listener).start();
  }
#+END_SRC

* big-theta

Ө(g(x)) is a *set* of functions.
big-Θ -- tight bound; both upper and lower bound(precise, but diﬃcult to compute)
Ө(g(x)) = {f(x) such that there exist positive constants c1, c2, N such that 0<=c1*g(x)<=f(x)<=c2*g(x) for all x>N}
The Big-Theta notation is symmetric: f(x) = Ө(g(x)) <=> g(x) = Ө(f(x))

we could write f(x) ∈ Ө(g(x))
but more commonly f(x) = Ө(g(x))
